## 개요



아키텍처 v1에서 spring application이 단일 서버였으나,

아키텍처 v2에서 spring application이 두개로 늘어나면서 무중단 배포도 같이 진행을 하게 되었다.

바뀐 코드 중심에서 아키텍처 중심적 배포를 하기 위해서 CI/CD 도구를 변경을 하게 되었다.

## 선택지


| 도구 | 주요 특징 | 장점 | 단점 |
| --- | --- | --- | --- |
| Jenkins | 오픈소스, 1,800+ 플러그인, 분산 빌드 지원 | 광범위한 확장성, 커스터마이징 용이, 강력한 커뮤니티 | UI가 다소 구식, 초기 설정 복잡 |
| GitLab CI/CD | GitLab 통합, 동시 테스트 및 배포 | 코드 저장소와 완벽 통합, 보안 기능 강화 | GitLab 생태계 의존적 |
| CircleCI | 클라우드 및 온프레미스 솔루션 | 빠른 설정, 확장성, 성능 최적화 | 높은 비용 구조, 커스터마이징 제한적 |
| Travis CI | GitHub 저장소 통합, 자동화된 테스트 | 간단한 구성, 다양한 언어 지원 | 복잡한 워크플로우에 제한적 |
| TeamCity | JetBrains 제품, 병렬 빌드 지원 | 사용자 친화적 UI, 세부적인 보고 기능 | 무료 버전 제한적, 리소스 요구 높음 |

여러 선택지를 검토한 결과, 아키텍처 v2의 핵심 목표는 **최대한 적은 리소스 비용을 발생시키는 것**이었다.

따라서 가능한 한 **낮은 사용료**로 운영이 가능해야 했으며,

앞으로 진행될 아키텍처 v3로의 확장에 있어서도 **기능적 제약이나 부족함이 없어야 했다**.

이는 v3에서 **더 많은 Spring 애플리케이션과 다양한 AWS 서비스**를 활용할 계획이었기 때문이다.

## 결정 및 이유


아키텍처 v2의 핵심 목표는 **최대한 적은 리소스 비용으로 운영이 가능하면서도**,

향후 아키텍처 v3로의 확장에 **제약이 없도록 유연하고 확장 가능한 기반**을 마련하는 것이었다.

이러한 목표에 따라 여러 CI/CD 도구를 비교한 결과, **Jenkins**가 다음과 같은 이유로 가장 적합한 선택이었다:

1. **오픈소스 기반**으로 사용료가 발생하지 않아 비용 부담이 없으며,
2. **1,800개 이상의 플러그인**과 **광범위한 커스터마이징 기능**을 통해
    
    v3에서 도입할 다양한 Spring 애플리케이션 및 AWS 서비스와의 연동도 유연하게 대응할 수 있다.
    
3. **분산 빌드 지원**을 통해 향후 빌드/배포 프로세스가 복잡해져도 무리 없이 확장할 수 있는 구조를 제공한다.

물론 UI가 다소 구식이며 초기 설정이 복잡하다는 단점은 있으나,

이는 **한 번의 설정 이후 비용 효율성과 확장성에서 충분히 상쇄**될 수 있는 부분이라고 판단하였다.

## 결론



결론적으로, **운영 시 리소스 비용을 최소화하면서도 높은 확장성**을 제공하는 Jenkins를 선택하게 되었다.

Jenkins는 다양한 플러그인을 통해 **유연한 커스터마이징과 확장이 가능**하다는 점에서

향후 아키텍처 v3 및 AWS 서비스와의 연동을 고려할 때 적합한 도구라고 판단하였다.

현재는 **t3.medium 인스턴스를 기준으로 월 약 4만 원 정도의 비용**이 예상되지만,

개발 단계에서는 Jenkins 서버를 **필요할 때만 구동**할 예정이므로

실제 비용은 **예상치의 절반 이하**로 절감될 것으로 보인다.

또한, 추후 AWS와의 연계 사용 시 Jenkins의 **자동화 효율성이 더욱 극대화될 것**이라 기대하고 있다.
